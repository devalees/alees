import factory
from factory.django import DjangoModelFactory
from django.contrib.auth import get_user_model

from ..models import Category
from ..choices import CategoryType

User = get_user_model()

class CategoryFactory(DjangoModelFactory):
    class Meta:
        model = Category
        # If using a unique slug and want factory to handle collisions:
        # django_get_or_create = ('slug',)

    name = factory.Sequence(lambda n: f'Category {n}')
    # slug is auto-generated by model's save method, no need to set here usually
    description = factory.Faker('text', max_nb_chars=100)
    parent = None # Can be set in tests for hierarchy
    category_type = factory.Iterator([choice[0] for choice in CategoryType.choices])
    is_active = True
    custom_fields = factory.LazyFunction(dict) # Use LazyFunction for mutable default

    # Add required Auditable fields. Assume a user exists or create one.
    # If a user fixture is commonly used, could potentially link it here,
    # but it's often cleaner to set these explicitly in tests using the factory.
    # created_by = factory.SubFactory(UserFactory) # Example if UserFactory exists
    # updated_by = factory.SelfAttribute('created_by')

    @factory.lazy_attribute
    def created_by(self):
        # Simple user creation/retrieval for the factory
        # WARNING: This creates a new user for each factory call if not exists,
        # which might be inefficient. Consider passing user in tests.
        user, _ = User.objects.get_or_create(username='factory_user', defaults={'password': 'password'})
        return user

    @factory.lazy_attribute
    def updated_by(self):
        # Use the same user as created_by
        return self.created_by 