## 4. File Storage Strategy (Cloud Focus)

**(Equivalent to a focused PRD for File Storage setup)**

### 4.1. Overview

*   **Purpose**: To define the strategy for storing and serving user-uploaded files (`FileField`, `ImageField`) associated with ERP models.
*   **Scope**: Selection of storage backend, Django integration, security considerations, local development setup, and configuration management.
*   **Chosen Technology**:
    *   **Production/Staging:** Cloud Storage (**AWS S3** assumed as primary example, adaptable to GCS/Azure Blob) via **`django-storages`** (`storages.backends.s3boto3.S3Boto3Storage`).
    *   **Local Development:** Django's built-in **`FileSystemStorage`**. *(Alternative: MinIO Docker container for S3 compatibility)*.

### 4.2. Core Requirements

*   **Scalable & Durable Storage**: Handle potentially large volumes and numbers of files reliably.
*   **Decoupled Storage**: Separate file storage from the main application server/database.
*   **Secure Access**: Control access to files, preventing unauthorized downloads.
*   **Efficient Serving**: Leverage cloud provider features (CDNs, direct downloads) for efficient file delivery.
*   **Django Integration**: Work seamlessly with Django's `FileField` and `ImageField`.

### 4.3. Configuration Strategy (`config/settings/`)

*   **Default Backend:** Configure `DEFAULT_FILE_STORAGE` setting:
    *   In `settings/prod.py` & `settings/staging.py`: `'storages.backends.s3boto3.S3Boto3Storage'`
    *   In `settings/dev.py`: `'django.core.files.storage.FileSystemStorage'`
    *   In `settings/test.py`: `'django.core.files.storage.FileSystemStorage'` (configured to use a temporary directory).
*   **Cloud Storage Settings (for S3 via `django-storages`/`boto3`):** Define settings like `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_STORAGE_BUCKET_NAME`, `AWS_S3_REGION_NAME`, `AWS_S3_CUSTOM_DOMAIN` (for CDN), `AWS_DEFAULT_ACL` (e.g., `private`), `AWS_S3_FILE_OVERWRITE` (`False` usually preferred), `AWS_S3_SIGNATURE_VERSION` (`s3v4`), `AWS_QUERYSTRING_AUTH` (`True` for signed URLs). Load **all sensitive credentials and bucket names from environment variables**.
*   **Local Storage Settings:** Define `MEDIA_URL` and `MEDIA_ROOT` in `settings/dev.py` and `settings/test.py`.
*   **File Validation Settings:** Define application-level settings for `MAX_UPLOAD_SIZE` and `ALLOWED_MIME_TYPES`.

### 4.4. Local Development Setup (`docker-compose.yml`)

*   Use `FileSystemStorage` by default.
*   Mount a local `./media/` directory into the Django container using Docker Compose volumes to persist uploads locally. Add `media/` to `.gitignore`.
*   *(Optional Advanced Dev):* Include a MinIO service in `docker-compose.yml` and configure `settings/dev.py` to use `S3Boto3Storage` pointing to the local MinIO instance for closer S3 parity.

### 4.5. Integration Points

*   **Django Models:** Used via `models.FileField` and `models.ImageField`.
*   **`FileStorage` Model (ERP):** The `file` field on the `FileStorage` metadata model uses the configured backend.
*   **API Views/Serializers:** Handle file uploads (`MultiPartParser`, validation) and generate download URLs.
*   **Storage Backend Library:** `django-storages` and underlying provider SDK (e.g., `boto3`).

### 4.6. Security Considerations

*   **Private Storage:** Cloud buckets/containers **must** be configured for private access by default.
*   **Access Control:** File access **must** be brokered through the Django application, which performs permission checks (based on Org Scope, RBAC applied to the `FileStorage` record or the linking object).
*   **Secure URLs:** Use **pre-signed URLs** (generated by `django-storages`/`boto3`) with short expiry times for providing download access directly from cloud storage. Avoid making files public.
*   **Credentials:** Manage cloud storage credentials securely (environment variables, IAM roles, secrets manager).
*   **Upload Validation:** Enforce file type and size limits during upload in the application to prevent abuse. Consider virus scanning on upload (external process/lambda).

### 4.7. Monitoring Considerations

*   Monitor cloud storage metrics (bucket size, number of objects, request counts, errors) via cloud provider tools.
*   Monitor application logs for upload/download errors.

### 4.8. Backup & Recovery Strategy

*   **Cloud Storage:** Rely primarily on the high durability guarantees of the cloud provider (e.g., S3's 99.999999999% durability). Enable bucket versioning for protection against accidental deletion/overwrite. Consider cross-region replication for disaster recovery if required. Regular backups of the *metadata database* are still essential.
*   **Local Storage (Dev):** Not typically backed up rigorously, rely on Git for code.

### 4.9. Testing Considerations

*   Use `FileSystemStorage` configured with a temporary directory (`tempfile.mkdtemp()`) in `settings/test.py`. `override_settings` can be used per test class.
*   Mock the `django-storages` backend (e.g., using `moto` for S3) for integration tests that specifically need to verify cloud storage interactions without making real calls.

### 4.10. Deployment Considerations

*   Create cloud storage bucket/container in each environment.
*   Configure bucket policies/ACLs for private access.
*   Set up IAM users/roles with appropriate permissions for the application to access the bucket.
*   Configure environment variables with credentials, bucket name, region, etc.
*   Configure CDN (e.g., CloudFront, Cloudflare) to serve files efficiently via signed URLs (optional but recommended).
*   Configure CORS on the bucket if direct browser uploads/access (even signed) is needed.
