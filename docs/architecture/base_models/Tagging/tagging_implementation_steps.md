## Updated: `tagging_implementation_steps.md` (Specified - Contact Example)

# Tagging System Integration - Implementation Steps

## 1. Overview

**Component Name:**
Tagging System Integration (using `django-taggit`)

**Corresponding PRD:**
`tagging_prd.md` (Simplified - No Custom Fields on Tags)

**Depends On:**
`django-taggit` library, Models that need to be tagged (e.g., **`Contact`**, `Organization`, `Product`, `Document`).

**Key Features:**
Integrates `django-taggit` using default models. Adds `TaggableManager` to target models. Enables tagging via model APIs.

**Primary Location(s):**
*   Library integration: `settings.py`, `requirements/*.txt`.
*   `TaggableManager` field added to models in: `api/v1/base_models/contact/models.py`, `api/v1/base_models/organization/models.py`, etc.
*   Admin: Relies on `taggit` default Admin integration and specific model admins (e.g., `ContactAdmin`).
*   Filtering Logic: `api/v1/base_models/contact/filters.py`, etc.
*   Serializer Integration: `api/v1/base_models/contact/serializers.py`, etc.

## 2. Prerequisites

[x] Install required library: `pip install django-taggit`.
[x] Add `'taggit'` to `INSTALLED_APPS` in `config/settings/base.py`.
[x] Decision made: **Use default `taggit.models.Tag`** (no custom fields on Tags).
[x] Ensure `factory-boy` is set up.

## 3. Implementation Steps (TDD Workflow)

  ### 3.1 Initial `taggit` Migration

  [x] Run `python manage.py makemigrations taggit`.
  [x] **Review generated migration file(s).**
  [x] Run `python manage.py migrate taggit` locally. Creates `taggit_tag` and `taggit_taggeditem` tables.

  ### 3.2 Factory Definition (`common/tests/factories.py` - Example Location)

  [ ] Define a basic `TagFactory` using the default model in a shared location:
      ```python
      # api/v1/base_models/common/tests/factories.py
      import factory
      from factory.django import DjangoModelFactory
      from taggit.models import Tag # Using default Tag model

      class TagFactory(DjangoModelFactory):
          class Meta:
              model = Tag
              django_get_or_create = ('name',) # Use name for uniqueness

          name = factory.Sequence(lambda n: f'Common Tag {n}')
          # slug is auto-generated by taggit
      ```
  [ ] **(Test)** Write a simple test ensuring `TagFactory` creates valid `Tag` instances.

  ### 3.3 Adding `TaggableManager` to Models (Incremental Task)

  *(Repeat this sub-task for each model that needs tagging. We start with `Contact`)*

  [ ] **Select Target Model:** **`Contact`** in `api/v1/base_models/contact/models.py`.
  [ ] **(Test First)** Write **Integration Test(s)** (`contact/tests/integration/test_models.py`) verifying:
      *   `contact.tags` exists and is a `TaggableManager`.
      *   `contact.tags.add("prospect", "vip")` works.
      *   `contact.tags.all()` returns the added tag(s).
      *   `Contact.objects.filter(tags__name__in=["prospect"])` works.
      Run; expect failure.
  [ ] **Implement:** Add `tags = TaggableManager(blank=True, verbose_name=_("Tags"))` to the `Contact` model definition. Import `TaggableManager`.
      ```python
      # api/v1/base_models/contact/models.py
      from django.db import models
      from django.utils.translation import gettext_lazy as _
      from taggit.managers import TaggableManager # Import
      from core.models import Timestamped, Auditable
      # ... other imports ...

      class Contact(Timestamped, Auditable):
          # ... other fields ...
          tags = TaggableManager(blank=True, verbose_name=_("Tags")) # Add manager
          # ... rest of model ...
      ```
  [ ] **Run Migrations:** Run `python manage.py makemigrations contact`. Review migration. Run `python manage.py migrate`.
  [ ] **Test & Refactor:** Run integration tests for `Contact` tagging; expect pass. Refactor.
  ---
  [ ] *(Apply later to Organization, Product, Document, etc. following the same pattern)*

  ### 3.4 Serializer Integration (Incremental Task)

  *(Repeat for each taggable model's serializer)*

  [ ] **Select Target Serializer:** **`ContactSerializer`** in `contact/serializers.py`.
  [ ] **(Test First)** Write **Unit/Integration Test(s)** (`contact/tests/unit/test_serializers.py`) verifying:
      *   `ContactSerializer` includes a `tags` field.
      *   Input data `{'tags': ['prospect', 'needs_followup']}` correctly sets tags on create/update.
      *   Serialized output includes `tags` as a list of strings: `{'tags': ['prospect', 'needs_followup']}`.
      Run; expect failure.
  [ ] **Implement:**
      *   Import `TagListSerializerField`, `TaggitSerializer` from `taggit.serializers`.
      *   Make `ContactSerializer` inherit from `TaggitSerializer`.
      *   Add `tags = TagListSerializerField(required=False)` to the serializer fields.
      *   Include `'tags'` in the `Meta.fields` list.
      ```python
      # contact/serializers.py (Example)
      from rest_framework import serializers
      from taggit.serializers import TagListSerializerField, TaggitSerializer # Import
      # ... other imports ...
      from ..models import Contact

      class ContactSerializer(TaggitSerializer, serializers.ModelSerializer): # Inherit TaggitSerializer
          tags = TagListSerializerField(required=False) # Add field
          # ... other fields like nested channels ...

          class Meta:
              model = Contact
              fields = [..., 'tags', ...] # Include tags
          # ... create/update methods for nested channels ...
          # TaggitSerializer handles tags field automatically
      ```
  [ ] **Test & Refactor:** Run `ContactSerializer` tests; expect pass. Refactor.
  ---
  [ ] *(Apply later to OrganizationSerializer, ProductSerializer, etc.)*

  ### 3.5 API Filtering Integration (Incremental Task)

  *(Repeat for each taggable model's ViewSet/FilterSet where tag filtering is needed)*

  [ ] **Select Target ViewSet/FilterSet:** **`ContactViewSet`** and potentially `ContactFilter` in `contact/views.py` and `contact/filters.py`.
  [ ] **(Test First)** Write **API Test(s)** (`contact/tests/api/test_endpoints.py`) verifying:
      *   `GET /api/v1/contacts/?tags__name__in=prospect,vip` returns contacts tagged with either 'prospect' OR 'vip'.
      Run; expect failure or incorrect filtering.
  [ ] **Implement:**
      *   Ensure `django-filter` is installed/configured.
      *   Create/Update the `FilterSet` (e.g., `ContactFilter`):
      ```python
      # contact/filters.py (Example)
      import django_filters
      from taggit.models import Tag
      from ..models import Contact

      class ContactFilter(django_filters.FilterSet):
          tags = django_filters.ModelMultipleChoiceFilter(
              field_name='tags__name',
              to_field_name='name',
              lookup_expr='in', # ANY tag match
              label='Tags (any of)',
              queryset=Tag.objects.all() # Use default Tag model
          )
          class Meta:
              model = Contact
              fields = ['tags', 'status', 'contact_type'] # Include tags and other fields
      ```
      *   Ensure the ViewSet (e.g., `ContactViewSet`) uses this `filterset_class` and includes `DjangoFilterBackend`.
      ```python
      # contact/views.py (Example)
      from django_filters.rest_framework import DjangoFilterBackend
      from .filters import ContactFilter # Import FilterSet

      class ContactViewSet(viewsets.ModelViewSet):
          # ... serializer_class, queryset, permissions ...
          filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter] # Add DjangoFilterBackend
          filterset_class = ContactFilter # Use the defined filterset
          # ...
      ```
  [ ] **Test & Refactor:** Run API filtering tests for `Contact`; expect pass. Refactor FilterSet/ViewSet.
  ---
  [ ] *(Apply later to Organization, Product, etc.)*

  ### 3.6 Admin Integration (Verification)

  [ ] Verify that for `ContactAdmin`, the interface automatically provides a field for managing tags.
  [ ] Verify the global `Tags` admin (under the `TAGGIT` app group) exists.
  [ ] **(Manual Test):** Add/remove tags via `ContactAdmin`. Check the global tag list.

## 4. Final Checks

[ ] Run the *entire* test suite (`pytest`). Ensure tests for tagging `Contact` (model, serializer, API filter) pass.
[ ] Run linters (`flake8`) and formatters (`black`).
[ ] Check code coverage (`pytest --cov`).
[ ] Manually test adding/removing tags and filtering via API client and Admin UI for `Contact`.
[ ] Review API documentation for the `Contact` endpoint, ensuring the `tags` field and filtering options are mentioned.

## 5. Follow-up Actions

[ ] Create Pull Request(s) for the `django-taggit` setup and integration into `Contact`.
[ ] Update relevant API documentation (`Contact` endpoint).
[ ] Apply tagging (Steps 3.3 - 3.5) to other required models (`Organization`, `Product`, `Document`, etc.) incrementally as they are implemented.

---